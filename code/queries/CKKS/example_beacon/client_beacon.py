"""
Client-side Operations for Beacon V2 FHE Bracket Queries
========================================================

The client (geneticist/researcher) performs these operations:
1. Generate cryptographic context and keys
2. Encrypt query coordinates (bracket ranges)
3. Share public key and evaluation keys with server
4. Decrypt comparison results from server
5. Keep secret key private at all times

KEYS IN FHE:
-----------
1. Secret Key: NEVER shared, used only for decryption
2. Public Key: Shared with server for encrypting variant data
3. Evaluation Keys: Shared with server (in crypto context) for homomorphic operations
   - Generated by EvalSchemeSwitchingKeyGen
   - Allow server to perform comparisons without seeing plaintext
"""

import openfhe as fhe
import time
import math
import psutil

def get_memory_usage_mb():
    """Monitor RAM usage during key generation and encryption"""
    process = psutil.Process()
    return process.memory_info().rss / 1024 / 1024


def setup_crypto_context(multDepth, scaleModSize, firstModSize, slots, secretKeyDist):
    """
    Setup CKKS crypto context for homomorphic comparisons
    
    CKKS allows approximate arithmetic on encrypted real numbers, which is needed
    for encoding genomic coordinates (large integers) and performing comparisons.
    
    Parameters:
        multDepth: Multiplicative depth (number of consecutive multiplications)
        scaleModSize: Scaling factor bit size
        firstModSize: First modulus size
        slots: Number of values to pack (4 for bracket query: 2 start + 2 end comparisons)
        secretKeyDist: Secret key distribution (UNIFORM_TERNARY for security)
    """
    sl = fhe.HEStd_128_classic  # 128-bit security level

    parameters = fhe.CCParamsCKKSRNS()
    parameters.SetMultiplicativeDepth(multDepth)
    parameters.SetScalingModSize(scaleModSize)
    parameters.SetFirstModSize(firstModSize)
    parameters.SetScalingTechnique(fhe.FLEXIBLEAUTOEXT)
    parameters.SetSecurityLevel(sl)
    parameters.SetBatchSize(slots)
    parameters.SetKeySwitchTechnique(fhe.HYBRID)
    parameters.SetSecretKeyDist(getattr(fhe, secretKeyDist))

    cc = fhe.GenCryptoContext(parameters)
    
    # Enable required operations
    cc.Enable(fhe.PKE)           # Public key encryption
    cc.Enable(fhe.KEYSWITCH)     # Key switching for operations
    cc.Enable(fhe.LEVELEDSHE)    # Leveled homomorphic operations
    cc.Enable(fhe.ADVANCEDSHE)   # Advanced operations
    cc.Enable(fhe.SCHEMESWITCH)  # Switching between CKKS and FHEW for comparisons

    return cc


def generate_keys_and_switching(cc, slots, logQ_ccLWE=25):
    """
    Generate all necessary keys for FHE operations
    
    CRITICAL SECURITY NOTE:
    - secretKey: NEVER leaves this function, only client has it
    - publicKey: Shared with server for encrypting variant data
    - evaluation keys: Generated here and shared via crypto context
    
    The scheme switching setup enables comparisons:
    - CKKS: Good for arithmetic on encrypted reals
    - FHEW: Good for comparisons (sign operations)
    - We need both for bracket query matching
    
    Returns:
        keys: Contains publicKey and secretKey
        keygen_time: Time taken for key generation
        mem_keygen_mb: Memory used for keys
        pLWE2: Parameter for FHEW scheme switching
    """
    start_keygen = time.perf_counter()

    mem_before_keygen = get_memory_usage_mb()
    keys = cc.KeyGen()  # Generates public key + secret key pair
    mem_after_keygen = get_memory_usage_mb()

    keygen_time = time.perf_counter() - start_keygen
    mem_keygen_mb = mem_after_keygen - mem_before_keygen

    # Setup scheme switching (CKKS → FHEW) for comparisons
    params = fhe.SchSwchParams()
    params.SetSecurityLevelCKKS(fhe.HEStd_128_classic)
    params.SetSecurityLevelFHEW(fhe.STD128)
    params.SetCtxtModSizeFHEWLargePrec(logQ_ccLWE)
    params.SetNumSlotsCKKS(slots)
    params.SetNumValues(slots)

    # Generate FHEW keys for comparison operations
    privateKeyFHEW = cc.EvalSchemeSwitchingSetup(params)
    ccLWE = cc.GetBinCCForSchemeSwitch()
    
    # Generate evaluation keys (these are stored in cc and will be shared with server)
    cc.EvalSchemeSwitchingKeyGen(keys, privateKeyFHEW)

    modulus_LWE = 1 << logQ_ccLWE
    beta = ccLWE.GetBeta()
    pLWE2 = int(modulus_LWE / (2 * beta))

    return keys, keygen_time, mem_keygen_mb, pLWE2


def encrypt_vector(cc, keys, x, slots):
    """
    Encrypt a vector using CKKS
    
    For bracket query, x = [start_min, start_max, end_min, end_max]
    These are the query ranges that the client wants to keep private.
    
    The encrypted vector can be sent to the server without revealing
    the actual coordinate values.
    """
    ptxt = cc.MakeCKKSPackedPlaintext(x, 1, 0, None, slots)
    start_encrypt = time.perf_counter()
    ctxt = cc.Encrypt(keys.publicKey, ptxt)
    encrypt_time = time.perf_counter() - start_encrypt
    return ctxt, encrypt_time


def decrypt_and_evaluate(cc, secretKey, cResults, expected_result, slots, eps=0.01):
    """
    Decrypt comparison results and check for matches
    
    The server returns encrypted comparison results. Only the client can
    decrypt these because only they have the secret key.
    
    For Beacon bracket query:
        expected_result = [-1, 1, -1, 1] means MATCH
        - -1: start_min ≤ variant_start
        - +1: variant_start ≤ start_max
        - -1: end_min ≤ variant_end
        - +1: variant_end ≤ end_max
    
    Returns:
        correct_count: Number of results matching expected pattern
        fail_count: Number of mismatches
        decrypt_times: Time taken for each decryption
    """
    decrypt_times = []
    correct_count = 0
    fail_count = 0

    for cResult in cResults:
        start_decrypt = time.perf_counter()
        result = cc.Decrypt(secretKey, cResult)
        decrypt_times.append(time.perf_counter() - start_decrypt)

        result.SetLength(slots)
        vals = result.GetRealPackedValue()
        
        # Round to -1 or 1 based on sign
        rounded = [1 if round(v / eps) * eps == 0 else -1 for v in vals]

        if rounded == expected_result:
            correct_count += 1
        else:
            fail_count += 1

    return correct_count, fail_count, decrypt_times


def client_pipeline(test_case, x1, x2, expected_result, multDepth, scaleModSize,
                    slots, secretKeyDist, scaleSignFHEW, reps):
    """
    Complete client-side workflow for Beacon FHE bracket query
    
    Workflow:
    1. Setup crypto context with CKKS parameters
    2. Generate keys (public, secret, evaluation)
    3. Encrypt query coordinates
    4. Validate scale parameter for comparisons
    5. Return encrypted query and keys for server use
    
    What gets shared with server:
    - cc (crypto context with evaluation keys)
    - publicKey (for server to encrypt its data)
    - c1 (encrypted query)
    
    What stays private:
    - secretKey (for decryption only)
    - x1 (plaintext query coordinates)
    
    Args:
        test_case: Test case identifier
        x1: Query ranges [start_min, start_max, end_min, end_max]
        x2: Variant coordinates [variant_start, variant_start, variant_end, variant_end]
        expected_result: Expected comparison results for match
        multDepth, scaleModSize, slots, secretKeyDist: CKKS parameters
        scaleSignFHEW: Scale for sign evaluation in FHEW
        reps: Number of repetitions for benchmarking
    """
    firstModSize = 60
    logQ_est = firstModSize + multDepth * (scaleModSize + 1)

    # Step 1: Setup crypto context
    cc = setup_crypto_context(multDepth, scaleModSize, firstModSize, slots, secretKeyDist)

    ringDim = cc.GetRingDimension()
    if ringDim > 65536:
        raise RuntimeError(f"Ring dimension too large: {ringDim}")

    # Step 2: Generate all keys
    keys, keygen_time, mem_keygen_mb, pLWE2 = generate_keys_and_switching(cc, slots)
    
    # Step 3: Encrypt query coordinates
    mem_before_encrypt = get_memory_usage_mb()
    c1, encrypt1_time = encrypt_vector(cc, keys, x1, slots)  # Client's query
    c2_demo, encrypt2_time = encrypt_vector(cc, keys, x2, slots)  # For demo purposes
    mem_after_encrypt = get_memory_usage_mb()

    mem_encrypt_mb = mem_after_encrypt - mem_before_encrypt
    encrypt_time_avg = (encrypt1_time + encrypt2_time) / 2

    # Step 4: Validate scale parameter
    try:
        cc.EvalCompareSwitchPrecompute(pLWE2, scaleSignFHEW)
        scaleSignFHEW_valid = scaleSignFHEW
    except Exception as e:
        raise RuntimeError(f"Scale {scaleSignFHEW} is not valid: {e}")

    return {
        "test_case": test_case,
        "multDepth": multDepth,
        "scaleModSize": scaleModSize,
        "firstModSize": firstModSize,
        "slots": slots,
        "keySwitchTechnique": "HYBRID",
        "secretKeyDist": secretKeyDist,
        "ringDim": ringDim,
        "logQ_estimated": logQ_est,
        "logQ_actual": math.log2(cc.GetModulus()),
        "keygen_time": keygen_time,
        "encrypt_time": encrypt_time_avg,
        "scaleSignFHEW": scaleSignFHEW_valid,
        "cc": cc,  # Shared with server (contains evaluation keys)
        "publicKey": keys.publicKey,  # Shared with server
        "secretKey": keys.secretKey,  # NEVER shared
        "c1": c1,  # Encrypted query shared with server
        "pLWE2": pLWE2,
        "expected_result": expected_result,
        "mem_keygen_mb": mem_keygen_mb,
        "mem_encrypt_mb": mem_encrypt_mb
    }
